[% var project = h.t('project'); %]
[% var ns = h.t('ns'); %]
[% var possess = pie.string.change(project, 'capitalize', 'possessive'); %]

<div class="copy">
  <h1>Models</h1>
  <p>
    [%= project %] models provide a simple interface for object management and observation. They even provide computed properties, just like Ember models.
  </p>

  <h3>Model Basics</h3>
  <p>
    Until ES2015's Object.observe standard is in place, model activity is managed through getters and setters. Each model contains a <em>data</em> object which the getters and setters manipulate. You can bootstrap a model with data by providing it to the constructor
  </p>

  [%= h.gist("modelAccessors.js") %]

  <p>
    [%= project %] models allow for path management as well.
  </p>

  [%= h.gist("modelPaths.js") %]

  <h3>Computed Properties</h3>
  <p>
    Models are given the ability to define properties which are computed based on other properties of the model. This is accomplished via the <em>compute</em> method.
  </p>

  [%= h.gist("modelComputed.js") %]

  <p>
    The <em>compute</em> method accepts the property name, functional definition, and the dependent properties (or paths). If the functional definition is ommitted, a function of the provided name will be retrieved from the instance itself. This is useful when dealing with inheritance.
  </p>

  [%= h.gist("modelComputed2.js") %]

  <h3>Observation</h3>
  <p>
    Attributes, paths, and subpaths of a model can be observed. Observers are invoked after a <em>set</em>, <em>sets</em>, or <em>merge</em> operation is conducted. When invoked, observers receive an array of change records. The array is enhanced with extra functionality as defined by the <em>changeSet</em> mixin.
  </p>

  [%= h.gist("modelObserver.js") %]
</div>
