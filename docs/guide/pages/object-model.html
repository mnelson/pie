[% var project = h.t('project'); %]
[% var ns = h.t('ns'); %]
[% var possess = pie.string.change(project, 'capitalize', 'possessive'); %]

<div class="copy">
  <h1>The Object Model</h1>
  <p>If you've used Ember, React, Base2, Prototype, etc, [%= possess %] object model should feel familiar. "Classes" are simply ordered collections of mixins. There are no prototypes. You never use the <em>new</em> keyword.</p>

  <h3>Inheritance</h3>

  <p>[%= ns %].base is the base-level "class" implementation used in [%= project %]. All classes "inherit" from [%= ns %].base, though not necessarily directly. So, how do you create a new class?</p>

  [%= h.gist('newClass.js') %]

  <p>See, easy as... most libraries. Let's try something a little more interesting now:</p>

  <code class="gist">
  User = pie.model.extend('User', {
    init: function(data, options) {
      this._super(data, options);

      this.validates({
        'firstName' : {presence: true},
        'lastName'  : {presence: true},
        'email'     : {email: true}
      });

      this.compute('fullName', 'firstName', 'lastName');
    },

    fullName: function() {
      return pie.array.compact([this.get('firstName'), this.get('lastName')], true]).join(' ');
    }

  }, pie.mixins.validatable);
  </code>

  <p>Ignoring all the <em>[%= ns %].model</em> specifics, let's see what's happening here.</p>

  <p>First, we're creating a subclass of [%= ns %].model by using <em>[%= ns %].model.extend</em>. Assuming the class is an ancestor of [%= ns %].base, you're able to subclass via the <em>extend</em> function. So, if I wanted to inherit from the User class, I would simply use <em>User.extend(...)</em>. The first argument provided to extend() is an optional string which is the name of the constructor. By providing this unique string it makes it much easier to debug in most browsers. If supplied, it will also be provided to both the class and instances of the class as the <em>__className</em> attribute. The next N arguments are the extensions to the class' schema.</p>

  <h3>Extensions and _super</h3>

  <p>The extensions provided to a class either via <em>extend()</em> or <em>reopen()</em> are added to the existing schema. When a new instance is instantiated, redefined functions are wrapped and provided with a <em>this._super</em> reference. <em>this._super</em> is simply a reference to the previously defined function. In the example above, the <em>lib.mixins.validatable</em> mixin can override the init function of the User class. In fact, the User's init function is overriding pie.model's and so on.</p>

  <code class="gist">
  var A = pie.base.extend({
    init: function(){
      console.log('A');
      this._super();
    }
  });

  var B = A.extend({
    init: function() {
      this._super();
      console.log('B1');
    }
  }, {
    init: function() {
      console.log('B2');
      this._super();
    }
  });

  var C = B.extend({
    init: function() {
      console.log('C');
      this._super();
    }
  });

  new C();
  //=>  "C"
  //=>  "B2"
  //=>  "A"
  //=>  "B1"
  </code>

  <h3>_super Gotchas</h3>

  <p>If you invoke another function belonging to your object which accepts a callback, you cannot assume this._super will be present within the callback. For example:</p>

  <code class="gist">
  // This WILL NOT work.
  pie.activeView.extend('AjaxView', {

    setup: function() {
      this.loadModel(function() {
        this._super();
      }.bind(this));
    },

    loadModel: function(cb) {
      app.ajax.get(...).success(cb);
    },
  });

  // This WILL work
  pie.activeView.extend('AjaxView', {

    setup: function() {
      // grab a local reference to _super.
      var sup = this._super.bind(this);
      this.loadModel(function() {
        // use the local reference instead of this._super
        sup();
      });
    },

    loadModel: function(cb) {
      app.ajax.get(...).success(cb);
    },
  });
  </code>

  <h3>Reopening</h3>

  <p>Both classes and instances can be <em>reopened</em>, allowing new function definitions with all the same _super functionality.</p>

  [%= h.gist('reopen.js') %]

  <p>You'll notice in the example above that even though the User class is reopened after the `u` instance is instantiated, the `u` instance receives the updates. However, when the `u` instance is reopened other instances do not gain the changes.</p>

</div>
